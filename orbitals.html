<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualize the Orbitals of Hydrogen</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            display: block;
            margin-left: 200px;
        }

        .sidebar {
            height: 100%;
            width: 200px;
            position: fixed;
            top: 0;
            left: 0;
            background-color: #222222;
        }

        h1 {
            margin-left: 20px;
            font-family: 'Arial';
            color: white;
            font-size: 28px;
        }

        h3 {
            margin-left: 10px;
            font-family: 'Arial';
            color: #cccccc;
        }
    </style>
</head>

<body>
    <div class="sidebar">
        <h1>Parameters</h1>
        <h3>Principal Quantum Number (n) (1-6)</h3>
        <h3>Angular Momentum Quantum Number (l) (0-3)</h3>
        <h3>Number of Points (100-1000000)</h3>
        <h3>Required Probability to Show (0-1)</h3>
    </div>
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.module.js';

        const height = window.innerHeight
        const width = window.innerWidth - 200

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });

        renderer.setSize(width, height);
        document.body.appendChild(renderer.domElement);
        camera.position.z = 10;

        // Function to generate points based on wavefunction squared
        function generateWavefunctionSquared(numPoints, maxRadius) {
            const vertices = [];
            const colors = [];

            for (let i = 0; i < numPoints; i++) {
                const r = Math.random() * maxRadius;
                const theta = Math.acos(2 * Math.random() - 1);
                const phi = Math.random() * 2 * Math.PI;

                const x = r * Math.sin(theta) * Math.cos(phi);
                const y = r * Math.sin(theta) * Math.sin(phi);
                const z = r * Math.cos(theta);

                // Calculate |psi|^2 as proportional to r^2 * e^(-r) * cos^2(theta)
                const density = Math.pow(r, 2) * Math.exp(-r) * Math.pow(Math.cos(theta), 2);

                if (density > 0.1) {
                    console.log(density)
                    // Add vertex
                    vertices.push(x, y, z);
                }




                // Map density to color intensity (using green, change as desired)
                const color = new THREE.Color(0x00ff00)//.multiplyScalar(density);
                colors.push(color.r, color.g, color.b);
            }

            return { vertices, colors };
        }

        // Generate points and colors
        const numPoints = 10000;
        const maxRadius = 25;
        const { vertices, colors } = generateWavefunctionSquared(numPoints, maxRadius);

        // Create geometry and set the vertices and colors
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

        // Set the material to use vertex colors
        const material = new THREE.PointsMaterial({ vertexColors: true, size: 0.05 });
        const pointCloud = new THREE.Points(geometry, material);
        scene.add(pointCloud);

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            pointCloud.rotation.y += 0.005;
            pointCloud.rotation.x += 0.005;
            renderer.render(scene, camera);
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });

        window.addEventListener('scroll', (event) => {
            console.log("h")
        })
    </script>
</body>

</html>